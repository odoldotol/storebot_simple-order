=> 주문서디비와 결제와 주문스트림 3가지의 동기화
=> 3가지중 하나의 문제시 다른 두가지를 통해 복구, 후보정가능

주문, 결제, 취소 정합성 배치프로세스

* 주문, 결제 구현
결제id로 주문서레코드 생성
결제승인 전 주문서레코드 확인/업데이트
결제승인 직후 주문스트림 푸시

=> 결제 전 주문서 레코드를 디비에 만들기 때문에 결제 취소시 오버헤드가 있음. (최소화 위해 필수적인 order, order_payment_method 동기적으로 생성하고 나머지는 비동기적으로 생성)
하지만 결제이후 에러발생시에도 주문서 디비를 기반으로 복구/보정으로 스트림추가가 가능함.


* 상태
주문서 결제 스트림
  F   F    F : 정상
  T   T    T : 정상
  T   T    F : 결제 승인 직후 다이 => 주문서 있고 결제있으나 주문스트림이 없는 경우 => 주문 스트림 푸시보정
  T   F    F : 주문서 레코드 확인되었으나 결제 승인 못함 => 결제 승인까지 완료 안되면 결제 에러 던저서 고객이 알 수 있게 해야함.(추가적으로 다시 결제의 편의성 고려해보기), 또는 고객이 결제 취소.
  T   F    T : 이런 경우는 불가능해야함. (결제 취소는 매장에서 승인해줘서 스트림 제거하고 가능) => 발견시 보정없이 로그 남겨서 확인하기.
  F   T    T : 이런 경우는 불가능해야함. (주문서는 쓰기만 가능) => 발견시 스트림과 결제정보 기반으로 주문서 후보정으로 쓰고 로그남기기.
  F   T    F : 이런 경우는 불가능해야함. => 발견시 로그남기기.
  F   F    T : 이런 경우는 불가능해야함. => 발견시 로그남기기.




* 보정/복구작업
주문서를 기반으로 결제정보를 찾고 있으면 스트림 확인 => 스트림 없으면 푸시해줌, 처리 로그남겨
배치로 계속 주문서 레코드






=> 핵심은 결제 유무다
결제 승인전 승인기록 해시맵에 추가
승인거부시 해시맵에서 제거
오더링에서 승인기록 처리후에 해시맵에서 제거
배치는 해시맵에 남아있는 승인기록을 처리(시간적 여유가 필요함)




=> 시스템 재가동시 복구 솔루션도 필요함
스트림은 자체 복구 솔루션으로 복구하고
복구된 스트림 기반으로 레코드와 결제정보를 확인하면서 복구하고
다시, 기준시간 이후 추가된 레코드중 스트림기반 복구에서 처리 안한 레코드를 찾고 그놈의 결제정보를 확인하면서 복구하면 됨