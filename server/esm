(1) 과 같은 이유로 ESM 빌드를 검토했으나
(2) 와 같은 이유로 CommonJS 선택.
대신, (3) 을 지켜보자.
추후 전환 시 (4) 참고하자.

---

# (1)
모듈 의존성 중앙화 하기위한 리팩토링중에 순환종속성을 더 잘 처리하는 ESM 으로 빌드 검토시작.

- 최신 표준 모듈 시스템. Node.js 공식 권장 방향.
- 최신 스펙 활용.
- 브라우저 환경과 동일한 모듈 시스템 -> 스토어클라이언트(브라우저|프론트) 협업에 이점?
- 번들 크기 최적화. 트리쉐이킹 가능 → 번들러(Webpack, Rollup, esbuild) 사용 시 최적화 용이 (백앤드는 뭐 별로 상관없자너)

# (2)
- CommonJS 가 여전히 Node.js 기본 모듈 시스템이고 NestJS 기본 설정임.
- 생태계 안정적 호환성. 세팅간편. 대부분의 npm 패키지가 여전히 CommonJS 기반. 일부 패키지는 ESM 지원 미흡.
- 특히, Jest, TypeORM 등 주요하게 쓸건데 CommonJS 가 호환좋고 안정적. ESM 쓰려면 세팅 번거로와져.
- 경로에 .js 확장자, 별칭 등, 경로 관련부분 우아하게 처리하기 까다로움.

# (3)
- 정적 import 패턴 온니, 동적 require() 금지. 특히 동적으로 코드읽어서 디스크IO 필요하게 하면 똥.
- __dirname/__filename 의존 필요시 유틸로 감싸두자.
- 경로 별칭 적절히 사용.
- 배럴(index.ts) 남용 주의(ESM 트리쉐이킹, 순환참조)
- Jest 같은거 설정 분리해두기.
- 혹시 짧은 수명 프로세스돌리는 서비스같은거 할때 번들 사이즈 최적화(트리쉐이킹) 어려운것 고려.
- 순환종속성 주의하자.
- CommonJS 에 의존적인 코드부분에 @CommonJS 주석 달아두자.

# (4)
- @CommonJS 주석 찾아봐라 (commonjs 에 의존적인 부분 체크)
- nestjs cli 에서 esm 관련 지원 좀 알아보자
- 경로 정공법(.js 까지 다 기입) vs 번들러(tsup 고려)
- ts-node tsx nodemon tsc-alias tsconfig-paths/register ... 이런 추가도구 최초화하자